from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import requests
import json
import base64
from PIL import Image, ImageDraw
import io
import numpy as np
import cloudinary
import cloudinary.uploader
from dotenv import load_dotenv
import time
import tempfile

# Load environment variables
load_dotenv()

app = Flask(__name__)
CORS(app)

# Configure Cloudinary
cloudinary.config(
    cloud_name=os.environ.get("CLOUDINARY_CLOUD_NAME"),
    api_key=os.environ.get("CLOUDINARY_API_KEY"),
    api_secret=os.environ.get("CLOUDINARY_API_SECRET")
)

# Hugging Face API settings
API_URL = os.environ.get("SD_API_URL")
headers = {"Authorization": f"Bearer {os.environ.get('HUGGINGFACE_API_KEY')}"}

# Temp directory for file storage
TEMP_DIR = "temp"
os.makedirs(TEMP_DIR, exist_ok=True)

@app.route('/', methods=['GET'])
def index():
    return jsonify({"status": "API is running"})

@app.route('/generate', methods=['POST'])
def generate():
    data = request.json
    prompt = data.get('prompt')
    
    if not prompt:
        return jsonify({"error": "No prompt provided"}), 400
    
    try:
        # Call Stable Diffusion API
        try:
            response = requests.post(
                API_URL,
                headers=headers,
                json={"inputs": prompt}
            )
            
            if response.status_code != 200:
                error_msg = f"Hugging Face API returned status code {response.status_code}"
                print(error_msg)
                print("Using fallback placeholder image...")
                # Use a fallback image
                placeholder_path = os.path.join(os.path.dirname(__file__), "placeholder.png")
                if os.path.exists(placeholder_path):
                    image = Image.open(placeholder_path)
                else:
                    # Create a simple placeholder image
                    image = Image.new('RGB', (512, 512), color=(73, 109, 137))
                    d = ImageDraw.Draw(image)
                    d.text((10, 10), f"Generated from: {prompt}", fill=(255, 255, 0))
                    image.save(placeholder_path)
            else:
                # Convert response to image
                image_bytes = response.content
                
                # Check if the response is valid JSON (error message) instead of an image
                try:
                    error_json = json.loads(image_bytes)
                    if 'error' in error_json:
                        return jsonify({"error": f"Hugging Face API error: {error_json['error']}"}), 500
                except json.JSONDecodeError:
                    # Not JSON, continue with image processing
                    pass
                
                try:
                    # Print information about the response for debugging
                    print(f"Response content type: {response.headers.get('Content-Type')}")
                    print(f"Response length: {len(image_bytes)} bytes")
                    
                    # Create BytesIO object from image bytes
                    image_io = io.BytesIO(image_bytes)
                    
                    # Check if the content is a valid image
                    image = Image.open(image_io)
                    image.verify()  # Verify it's a valid image
                    
                    # Reopen the image as verify() closes the file
                    image_io = io.BytesIO(image_bytes)
                    image = Image.open(image_io)
                except Exception as e:
                    print(f"Error opening image: {str(e)}")
                    return jsonify({"error": f"Failed to process image from API: {str(e)}"}), 500
        except Exception as req_error:
            print(f"Request error: {str(req_error)}")
            return jsonify({"error": f"Failed to request image: {str(req_error)}"}), 500
            
        # Save image temporarily
        timestamp = int(time.time())
        image_filename = f"image_{timestamp}.png"
        image_path = os.path.join(TEMP_DIR, image_filename)
        
        try:
            image.save(image_path)
        except Exception as e:
            print(f"Error saving image: {str(e)}")
            return jsonify({"error": f"Failed to save image: {str(e)}"}), 500
        
        # Upload to Cloudinary
        try:
            upload_result = cloudinary.uploader.upload(image_path)
        except Exception as e:
            print(f"Error uploading to Cloudinary: {str(e)}")
            return jsonify({"error": f"Failed to upload image to Cloudinary: {str(e)}"}), 500
        
        # Generate depth map
        try:
            depth_map = generate_depth_map(image)
            depth_filename = f"depth_{timestamp}.png"
            depth_path = os.path.join(TEMP_DIR, depth_filename)
            depth_map.save(depth_path)
            
            # Upload depth map to Cloudinary
            depth_upload_result = cloudinary.uploader.upload(depth_path)
        except Exception as e:
            print(f"Error generating depth map: {str(e)}")
            return jsonify({"error": f"Failed to generate depth map: {str(e)}"}), 500
        
        # Generate 3D model (OBJ file)
        try:
            obj_filename = f"model_{timestamp}.obj"
            obj_path = generate_3d_model(image_path, depth_path, obj_filename)
            
            # Upload OBJ to Cloudinary
            obj_upload_result = cloudinary.uploader.upload(
                obj_path,
                resource_type="raw"
            )
        except Exception as e:
            print(f"Error generating 3D model: {str(e)}")
            return jsonify({"error": f"Failed to generate 3D model: {str(e)}"}), 500
        
        return jsonify({
            "message": "Generation successful",
            "image": upload_result["secure_url"],
            "depth": depth_upload_result["secure_url"],
            "obj_file": obj_upload_result["secure_url"]
        })
    
    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({"error": str(e)}), 500

def generate_depth_map(image):
    """Generate a depth map from the provided image using MiDaS."""
    # This is a simplified placeholder function
    # In a real implementation, you would use a depth estimation model like MiDaS
    
    # Convert to grayscale as a simple placeholder for depth
    depth_map = image.convert("L")
    return depth_map

def generate_3d_model(image_path, depth_path, obj_filename):
    """Generate a 3D model from the image and depth map."""
    # This is a simplified placeholder function
    # In a real implementation, you would use the depth map to create a 3D mesh
    
    # For now, just create a simple OBJ file
    obj_path = os.path.join(TEMP_DIR, obj_filename)
    
    with open(obj_path, 'w') as f:
        f.write("# Simple cube OBJ file\n")
        
        # Vertices
        f.write("v -1.0 -1.0 -1.0\n")
        f.write("v 1.0 -1.0 -1.0\n")
        f.write("v 1.0 1.0 -1.0\n")
        f.write("v -1.0 1.0 -1.0\n")
        f.write("v -1.0 -1.0 1.0\n")
        f.write("v 1.0 -1.0 1.0\n")
        f.write("v 1.0 1.0 1.0\n")
        f.write("v -1.0 1.0 1.0\n")
        
        # Faces
        f.write("f 1 2 3 4\n")
        f.write("f 5 6 7 8\n")
        f.write("f 1 2 6 5\n")
        f.write("f 2 3 7 6\n")
        f.write("f 3 4 8 7\n")
        f.write("f 4 1 5 8\n")
    
    return obj_path

@app.route('/generate_depth', methods=['POST'])
def generate_depth_endpoint():
    data = request.json
    image_url = data.get('imagePath')
    
    if not image_url:
        return jsonify({"error": "No image URL provided"}), 400
    
    try:
        # Download the image
        response = requests.get(image_url)
        image = Image.open(io.BytesIO(response.content))
        
        # Generate depth map
        depth_map = generate_depth_map(image)
        
        # Save and upload
        timestamp = int(time.time())
        depth_filename = f"depth_{timestamp}.png"
        depth_path = os.path.join(TEMP_DIR, depth_filename)
        depth_map.save(depth_path)
        
        # Upload to Cloudinary
        upload_result = cloudinary.uploader.upload(depth_path)
        
        return jsonify({
            "message": "Depth map generated successfully",
            "depthMapPath": upload_result["secure_url"]
        })
    
    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/generate_model', methods=['POST'])
def generate_model_endpoint():
    data = request.json
    image_url = data.get('imagePath')
    depth_url = data.get('depthMapPath')
    
    if not image_url or not depth_url:
        return jsonify({"error": "Image URL and depth map URL are required"}), 400
    
    try:
        # Download the image and depth map
        img_response = requests.get(image_url)
        depth_response = requests.get(depth_url)
        
        # Save temporarily
        timestamp = int(time.time())
        img_filename = f"img_{timestamp}.png"
        depth_filename = f"depth_{timestamp}.png"
        obj_filename = f"model_{timestamp}.obj"
        
        img_path = os.path.join(TEMP_DIR, img_filename)
        depth_path = os.path.join(TEMP_DIR, depth_filename)
        
        with open(img_path, 'wb') as f:
            f.write(img_response.content)
        
        with open(depth_path, 'wb') as f:
            f.write(depth_response.content)
        
        # Generate 3D model
        obj_path = generate_3d_model(img_path, depth_path, obj_filename)
        
        # Upload to Cloudinary
        upload_result = cloudinary.uploader.upload(
            obj_path,
            resource_type="raw"
        )
        
        return jsonify({
            "message": "3D model generated successfully",
            "modelPath": upload_result["secure_url"]
        })
    
    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
